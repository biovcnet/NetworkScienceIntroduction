---
title: "Network Science Lesson 01"
output: html_notebook
---

In this lesson we will be generating a basic statistical association network form the Tara Oceans data that we can load into cytoscape.

# Installation

We'll need a few packages for this tutorial. Lets load them in. If you don't have any of these, you can install them using the `install.packages` function.

eg `install.packages("tidyverse")`

If you don't have SpiecEasi, you can dowload it as follows. Note, you need to `install.packages("devtools")` if you haven't ever done that before.

I commented the following lines out because I don't want to re-run them every time I test this notebook out. Uncomment them and run if you need them.

```{r}
#library(devtools)
#install_github("zdk123/SpiecEasi")
```

This took a while on my computer, you may want to get a cup of coffee while this runs.

# Loading Libraries

```{r}
library(tidyverse)
library(readxl)
library(SpiecEasi)
library(otuSummary)
#library(compositions) # we use this to clr transform data
library(reshape2)
library(psych) # for calculating regular correlations with p values
pass <- function(x){x}
```

# Gathering data

First, lets dowload the Tara Oceans data from the internets.
This data are read numbers of different phyla level bacterial and archaeal groups.
They are 16s genes but are from shotgun metagenomic sequencing.

```{r}
TaraPhyla <- read_tsv("https://www.ebi.ac.uk/metagenomics/api/v1/studies/MGYS00000410/pipelines/2.0/file/ERP001736_phylum_taxonomy_abundances_v2.0.tsv")
```

Please look over the new TaraPhyla object in your global environment. You can see that the first two columns are the Kindom and Phylum information for a bunch of bacterial and archaeal phyla. The rest of the columns are the number of reads associated with those phyla at each station. The station names are at the top.

# Pre-processing

While I'm a tidy-verse fanatic and like working with data in dataframes. If you want to correlate everything vs everything, its often best to transmute our data into a data frame. 

```{r}
TaraPhylaMtx0 <- TaraPhyla %>%
  select(-kingdom)  %>% # remove kingdom column
  filter(phylum != "unassigned") %>%
  mutate(phylum = make.unique(phylum)) %>% # if you don't remove "unassigned, there are two phyla with this name and you have problems without this line
  column_to_rownames(var = "phylum") %>% # turn phylum into row.names of data frame
  as.matrix() %>% # transmogrify data.frame into matrix
  t() %>% # transpose, so the OTUs are the columns and samples are the rows
  pass
  
TaraPhylaMtx0[1:5, 1:5] # Take a look at part of the matrix
```

It is is recommended to remove any species  with fewer than two reads on average.

```{r}
SpeciesToKeep <- apply(TaraPhylaMtx0, 2, mean) > 2

TaraPhylaMtx <- TaraPhylaMtx0[,SpeciesToKeep]
```

# Simple correlation analysis
The simplist way to look for associations in data is through correlation analyis. There are some problems with applying correlations to this kind of data and we'll come back to that. For now though, lets calculate the spearman correlations on the data

I'm using the corr.test function from the `psych` library, because it returns p values. I'm not adjusting for multiple comparasons up front. We'll do that later.

```{r}
#spearCor <- cor(TaraPhylaMtx, method = "spearman")
spearCorTest <- corr.test(TaraPhylaMtx, method = "spearman", adjust = "none")
spearCor <- spearCorTest$r
spearP <- spearCorTest$p
```

Now we have a matrix of spearman correlations and a matrix of p values.

## Plotting the results

I'm using a solution from here.
http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization
```{r}
## Helper functions
# Get lower triangle of the correlation matrix
  get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
  }
  # Get upper triangle of the correlation matrix
  get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }

reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

reorder_cor_and_p <- function(cormat, pmat){
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
  pmat <- pmat[hc$order, hc$order]
  list(r = cormat, p = pmat)
}

reordered_all <- reorder_cor_and_p(spearCor, spearP)
reordered_spearCor <- reordered_all$r
reordered_spearP <- reordered_all$p


spearCor_processed <- reordered_spearCor  %>% get_upper_tri() %>% reshape2::melt() %>% na.omit() %>% rename(rho = value)
spearP_processed <- reordered_spearP  %>% get_upper_tri() %>% reshape2::melt() %>% na.omit() %>% rename(p = value)

# join the two data frames

spearRhoP <- left_join(spearCor_processed, spearP_processed, by = c("Var1", "Var2")) %>%
  # # remove self correlations
  # filter(Var1 != Var2) %>% 
  # calculate the false discovery rate to adjust for multiple p values
  mutate(fdr = p.adjust(p, method = "BH"))

spearRhoP
```




```{r, fig.width= 10, fig.height = 10}

# Identify which pairs are "statistically significant, given our fdr threshold"
fdrThresh <- 0.01 # fdr threshold
spearOkP <- spearRhoP%>% filter(fdr < fdrThresh) 

spearRhoP_plot <- spearRhoP %>% ggplot(aes(x = Var2, y = Var1, fill = rho)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + geom_point(data = spearOkP)
spearRhoP_plot
```


# As above, but using Clr to adjust for compositionality
The centered log ratio converts relative abundance data to ratio data. Here every species is reported as the log of its ratio of the average (actually geometric average, rather than additive average) bacterium in that column
```{r}
TaraPhylaMtxClr <- clr(TaraPhylaMtx)
```

Then we just do spearman correlation on the clr transformed data.

```{r}
spearCorClr <- stats::cor(TaraPhylaMtxClr, method = "spearman")
```

And plot the data

```{r, fig.width= 10, fig.height = 10}
spearCorClr_toPlot <- spearCorClr %>% reorder_cormat() %>% get_upper_tri() %>% reshape2::melt() %>% na.omit()

spearCorClr_plot <- spearCorClr_toPlot %>% ggplot(aes(x = Var2, y = Var1, fill = value)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))

spearCorClr_plot
```



# Analysisis with sparcc

At this point, I found this torial helpful.
https://rachaellappan.github.io/16S-analysis/correlation-between-otus-with-sparcc.html

`sparcc` expects a `matrix` with OTU columns and sample rows. We want to name the rows and columns with row and column names. Lets do this processing









```{r}
out <- sparcc(TaraPhylaMtx)
```

Out is the output of sparcc. It contains a correlation and covariance matrix. Lets look at the first part of the correlation matrix.

```{r}
out$Cor[1:5, 1:5]
```

I'm kind of annoyed that it threw away my site names. Lets add them back

```{r}
rownames(out$Cor) <- colnames(TaraPhylaMtx)
colnames(out$Cor) <- colnames(TaraPhylaMtx)
rownames(out$Cov) <- colnames(TaraPhylaMtx)
colnames(out$Cov) <- colnames(TaraPhylaMtx)
#cout <- as.data.frame(out$Cor)
out$Cor[1:5, 1:5]
```

Better.

## Plotting Sparcc correlation

```{r , fig.width= 10, fig.height = 10}
plotableSparcc <- out$Cor %>% reorder_cormat %>% get_upper_tri() %>% reshape2::melt() %>% na.omit()

Sparcc_plot <- plotableSparcc %>% ggplot(aes(x = Var2, y = Var1, fill = value)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
Sparcc_plot
```

# Comparing the three correlation matrices
```{r fig.width= 8, fig.height = 15}
cowplot::plot_grid(
spearCor_plot,
spearCorClr_plot,
Sparcc_plot , nrow = 3
)
```

Certainly these look different from eachother. None seem intrinsically better just by looking at them, though.

## Calculating Sparcc Pvalues

Next, we need to calculate p-values. We do that by bootstrapping the sparcc values and then calculating p-values from those. 

The text below bootstraps things.

```{r}
tp0 <- proc.time()
out2 <- sparccboot(TaraPhylaMtx, R = 100)
tp1 <- proc.time()
tp1 - tp0
```

This took four minutes on my laptop. So in principal, running 1000 permutations (recommended) would take about an 40 minutes or I could use the multicore option. Lets proceed with this 100 permutation version for now.

Here's a multicore version, if you have multiple cores on your computer you can use it and things will go faster.
Doesn't work in RStudio Cloud.

```{r}
# tp0 <- proc.time()
# out2 <- sparccboot(TaraPhylaMtx, R = 1000, ncpus = 7)
# tp1 <- proc.time()
# tp1 - tp0
```
elapsed 108 with 4 cores
77 with 8 cores

Then we calculate the p values form the bootstrapped values.

```{r}
outP <- pval.sparccboot(out2)
data.frame(outP$cors, outP$pvals) %>% head
```

You'll notice these values are hard to use because they don't tell you which p-values correspond to which species. I dug around online and found that these are the lower part of a diagnonal matrix. 
https://github.com/zdk123/SpiecEasi/issues/17
You can rescue the data as follows.

```{r}
cors <- outP$cors
pvals <- outP$pvals
sparCCpcors <- diag(0.5, nrow = dim(out$Cor)[1], ncol = dim(out$Cor)[1])
sparCCpcors[upper.tri(sparCCpcors, diag=FALSE)] <- cors
sparCCpcors <- sparCCpcors + t(sparCCpcors)

sparCCpval <- diag(0.5, nrow = dim(out$Cor)[1], ncol = dim(out$Cor)[1])
sparCCpval[upper.tri(sparCCpval, diag=FALSE)] <- pvals
sparCCpval <- sparCCpval + t(sparCCpval)

rownames(sparCCpcors) <- colnames(TaraPhylaMtx)
colnames(sparCCpcors) <- colnames(TaraPhylaMtx)
rownames(sparCCpval) <- colnames(TaraPhylaMtx)
colnames(sparCCpval) <- colnames(TaraPhylaMtx)

sparCCpcors[1:5, 1:5]
sparCCpval[1:5, 1:5]
```

For reasons that are unclear to me, the correlation values saved by the sparcc pval program are a little different than the ones from sparcc. We'll use these ones, for no particular reason. I've submitted an issue report here, which you can follow, in case anything happens:
https://github.com/zdk123/SpiecEasi/issues/121


Cytoscape expects the correlation matrix to be in "long" format. So each row is a pair of variables and their correlation.
Matrixconvert makes things long format and also only takes the lower diagonal of the matrix so we don't have duplicate values.

```{r}
sparCCpcorsLong <- matrixConvert(sparCCpcors) %>%  rename(phy1 = sp1, phy2 = sp2, sparCC = dist)
sparCCpvalLong <- matrixConvert(sparCCpval) %>%  rename(phy1 = sp1, phy2 = sp2, p = dist)
```

Now lets combine the data and save them out so we can load things into cytoscape.
```{r}
toWrite <- left_join(sparCCpcorsLong, sparCCpvalLong, by = c("phy1", "phy2")) 
toWrite %>% head
write_csv(toWrite, "TaraOceansSparCC_p100.csv")
```

